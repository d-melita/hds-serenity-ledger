\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		\LARGE \textbf{Highly Dependable Systems
		\HRule{2.0pt} \\ [0.6cm] \LARGE{Project Report - First Delivery} \vspace*{10\baselineskip}}
		}
\date{March 8th 2024}
\author{\textbf{Authors} \\ 
		Carolina Coelho - 99189\\
		Diogo Melita - 99202\\
		Diogo Antunes - 99210}

%\includegraphics[scale=0.2]{ist-logo.png}
\maketitle
\newpage

% ------------------------------------------------------------------------------

\section{Objective}

This project aims to develop a simplified permissioned blockchain system with high
dependability guarantees. At the consensus layer, the system uses the Istanbul BFT 
consensus algorithm. For this stage, the main goal is to extend an incomplete version 
of the IBFT  algorithm and use a Public Key Infrastructure (PKI) to ensure the 
authenticity of the messages exchanged between the nodes.

\section{PKI}
The PKI module is responsible for managing the public and private keys of the nodes. 
The blockchain members should use the PKI module to self-generate their public and 
private keys, which are pre-distributed prior to the start of the system. Additionally, 
the PKI module is also responsible for signing and verifying messages as well as generating 
secret keys and HMACs for the communication between the nodes.

% \begin{figure}[htbp]
%     \center
%     \includegraphics[scale=0.06]{img/photo.jpg}
%     \caption{Sydney, NSW}
% \end{figure}


\section{Authenticated Perfect Links}
From the Fair-Loss Link abstraction, we built the Authenticated Perfect Link. Each message 
sent through incorporates a digital signature (DS) that is computed by encrypting the 
digest of the message with the sender's private key. Upon receiving a message the receiver 
can then verify the signature and, if it is valid, store the message and reply with an 
ACK, notifying the sender that the message was received.

\section{HMAC Links}
The HMAC Links are responsible for setting a secure channel between two nodes. Upon creation, 
the node with lower ID will try to establish a secure channel with the other node. To do so, 
this node will generate a secret key, sign it and cipher the secret key with the public key of 
the receiving node. Upon receiving the key proposal message, the node will decrypt the secret 
key and verify the signature. If everything is correct, it will reply with an ACK. After this 
secure connection is established, all the messages sent between the two nodes will incorporate 
an HMAC, which is computed by hashing the message with the secret key agreed to. Upon receiving 
a message, the receiver will verify the HMAC and, if it is valid, store the message and reply 
with an ACK, notifying the sender that the message was received.

This module is used to ensure the integrity and authenticity of the messages exchanged between 
the nodes.


\section{Consensus}
Consensus is achieved by a set of nodes that follow the QBFT algorithm. Each node is listening 
on a given port for requests from other nodes and on another port for requests form the clients. 
The nodes communicate with each other using a broadcast primitive and with the clients using a send 
primitive, all based on the Authenticated Perfect Links. 

\section{Application}
For this stage, the application is a simple client that reads commands from the terminal and calls 
an API from the library, which is responsible for communicating with the Legder Service. We implemented 
two services, one responsible for the communication with the clients (HDSLegderService) and another responsible 
for communicating with the nodes in order to start consensus algorithm upon receiving a request from the client 
(NodeService). 

Upon receiving an append request from the client, the HDSLegderService will invoke the NodeService to start a new 
consensus instance. The inputs are added to a blocking-queue by the NodeService once we do not start a new consensus 
instance if there is already one running. The NodeService keeps a thread running where it listens for new messages 
from the consensus algorithm. Once a consensus instance is finished, the NodeService will add the decision to a 
... and the HDSLedgerService has an observer that is notified when a new decision is made ?????

\section{Architecture}
Our implementation is based on multiple services doing asynchronous work. This 
involves having a service that is responsible for receiveing the client's requests and responding to 
them, and another service running on each node that is responsible for the IBFT consensus algorithm.
To serialize and deserialize data we use Google's GSON library.

mention assumption on ids,
strategy to ensure protocol is O(n2), 
approach to parallelization and locking


\newpage

% ------------------------------------------------------------------------------
% Reference and Cited Works
% ------------------------------------------------------------------------------

\bibliographystyle{IEEEtran}
% \bibliography{References.bib}

% ------------------------------------------------------------------------------

\end{document}
