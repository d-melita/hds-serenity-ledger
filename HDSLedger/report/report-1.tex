\documentclass{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{float}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{framed}
\usepackage[dvipsnames]{xcolor}
\usepackage{tcolorbox}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}

% ------------------------------------------------------------------------------

\begin{document}

% ------------------------------------------------------------------------------
% Cover Page and ToC
% ------------------------------------------------------------------------------

\title{ \normalsize \textsc{}
		\\ [2.0cm]
		\HRule{1.5pt} \\
		\LARGE \textbf{Highly Dependable Systems
		\HRule{2.0pt} \\ [0.6cm] \LARGE{Project Report - First Delivery} \vspace*{10\baselineskip}}
		}
\date{March 8th 2024}
\author{\textbf{Authors} \\ 
		Carolina Coelho - 99189\\
		Diogo Melita - 99202\\
		Diogo Antunes - 99210}

%\includegraphics[scale=0.2]{ist-logo.png}
\maketitle
\newpage

% ------------------------------------------------------------------------------

\section{Objective}

This project aims to develop a simplified permissioned blockchain system with high
dependability guarantees. At the consensus layer, the system uses the Istanbul BFT 
consensus algorithm. For this stage, the main goal is to extend an incomplete version 
of the IBFT  algorithm and use a Public Key Infrastructure (PKI) for message  
authenticity between nodes.

\section{PKI}
The PKI module manages nodes' public and private keys. The blockchain members should use 
the PKI module to self-generate their public and private keys, which are pre-distributed 
prior to the start of the system. Additionally, the PKI module is also responsible for 
signing and verifying messages as well as generating secret keys and HMACs for the communication 
between the nodes.

\section{Authenticated Perfect Links}
From the Fair-Loss Link abstraction, we built the Authenticated Perfect Link. Each message 
sent through it includes a digital signature (DS), generated by encrypting the message's 
digest with the sender's private key. Upon receipt, the receiver verifies the signature and, 
if it is valid, stores the message and responds with an ACK to confirm receipt.

\section{HMAC Links}
The HMAC Links are responsible for setting a secure channel between two nodes. Upon creation, 
the node with lower ID will try to establish a secure channel with the other node. To do so, 
this node will generate a secret key, sign it and cipher the secret key with the public key of 
the receiving node. Upon receiving the key proposal message, the node will decrypt the secret 
key and verify the signature. If everything is correct, it will reply with an ACK. After this 
secure connection is established, all the messages sent between the two nodes will incorporate 
an HMAC, which is computed by hashing the message with the secret key agreed to. Upon receiving 
a message, the receiver will verify the HMAC and, if it is valid, store the message and reply 
with an ACK, notifying the sender that the message was received.

This module is used to ensure the integrity and authenticity of the messages exchanged between 
the nodes.

\section{Consensus}
Consensus is achieved by a set of nodes that follow the QBFT algorithm. Each node is listening 
on a given port for requests from other nodes and on another port for requests form the clients. 
The nodes communicate with each other using a broadcast primitive and with the clients using a send 
primitive, all based on the Authenticated Perfect Links. - TODO CHECK this.

\section{Application}
For this stage, the application is a simple client that reads commands from the terminal and calls 
an API from the library, which is responsible for communicating with the Legder Service. We implemented 
two services, one responsible for the communication with the clients (HDSLegderService) and another responsible 
for communicating with the nodes in order to start consensus algorithm upon receiving a request from the client 
(NodeService). 

Upon receiving an append request from the client, the HDSLegderService will invoke the NodeService to start a new 
consensus instance. The inputs are added to a blocking-queue by the NodeService once we do not start a new consensus 
instance if there is already one running. The NodeService keeps a thread running where it listens for new messages 
from the consensus algorithm. Once a consensus instance is finished, the NodeService will add the decision to a 
... and the HDSLedgerService has an observer that is notified when a new decision is made ?????

\section{Architecture}
Our implementation is based on multiple services doing asynchronous work. This 
involves having a service that is responsible for receiveing the client's requests and responding to 
them, and another service running on each node that is responsible for the IBFT consensus algorithm.
To serialize and deserialize data we use Google's GSON library.

The system uses nodes and clients. For simplicity, we assume that the first n-1 ids correspond to the 
nodes and the remaining to the clients. This is done to simplify the communication as the clients and the 
nodes are aware of each other at the start of the system.

strategy to ensure protocol is O(n2), - dsa 
approach to parallelization and locking - dsa


\newpage

% ------------------------------------------------------------------------------
% Reference and Cited Works
% ------------------------------------------------------------------------------

\bibliographystyle{IEEEtran}
% \bibliography{References.bib}

% ------------------------------------------------------------------------------

\end{document}
